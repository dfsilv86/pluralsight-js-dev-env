<databaseChangeLog
		xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext"
		xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.0.xsd
		http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd">

	<changeSet id="hotfix-3-3-2-PRC_ATENDEPEDIDOMINIMO_2" author="dzanell">
		<sql stripComments="false" endDelimiter="">
			<![CDATA[  

ALTER PROCEDURE [dbo].[PRC_ATENDEPEDIDOMINIMO] 	 @idLoja INT
                                                ,@idFornecedorParametro BIGINT
                                                ,@DataPedido DATE
                                                ,@blAdicionaPack BIT = 1
AS
BEGIN
	--PEDIDO MINIMO DO ITEM
	IF OBJECT_ID('Tempdb..#TmpMinimoItem') IS NOT NULL 
	BEGIN
		DROP TABLE #TmpMinimoItem
	END

	CREATE TABLE #TmpMinimoItem ( IDSugestaoPedido INT, qtdPackCompra INT, blAtendePedidoMinimoItem BIT, vlMinimo NUMERIC(9,2), vlEstoque NUMERIC(11,3),
								qtVendorPackage INT, vlFatorConversao FLOAT, vlForecastMedio NUMERIC(11,3), vlShelflife INT, vlTipoReabastecimento SMALLINT,
								tpCaixaFornecedor CHAR(1), RequerMultiploMinimo BIT, AtendeMultiploMinimo BIT, AtendeSemAdicao BIT, 
								qtdPackCompraForecast INT, qtdPackCompraAjustado INT, AjustadoAtende BIT, PraCima INT, PraBaixo INT,
								TetoAtende BIT, ChaoAtende BIT);
	WITH Itens AS (
		-- Determina todos os itens que devem ser validados em relacao ao requisito do pedido minimo do item
		SELECT SP.IDSugestaoPedido, ISNULL(SP.qtdPackCompra, 0) AS qtdPackCompra, SP.blAtendePedidoMinimoItem, ISNULL(ID.vlMinimo, 0) AS vlMinimo
			 , SP.vlEstoque, SP.qtVendorPackage, SP.vlFatorConversao, ISNULL(SP.vlForecastMedio, 0) AS vlForecastMedio, SP.vlShelfLife
			 , SP.vlTipoReabastecimento, SP.tpCaixaFornecedor
			 , CASE WHEN ISNULL(SP.tpCaixaFornecedor, '') = 'F' AND SP.vlTipoReabastecimento IN (7,37,97) AND SP.vlForecastMedio > 0 THEN 1 ELSE 0 END AS RequerMultiploMinimo  -- DSD Fixo precisa arredondar conforme multiplo do minimo do item
			 , CASE WHEN SP.vlTipoReabastecimento IN (7,37,97) AND SP.vlForecastMedio > 0 AND vlMinimo > 0 AND qtdPackCompra % vlMinimo = 0 THEN 1 ELSE 0 END AS AtendeMultiploMinimo            -- se já é multiplo do minimo do item
			 , CASE WHEN SP.qtdPackCompra > 0 AND SP.qtdPackCompra >= ISNULL(ID.vlMinimo, 0) THEN 1 ELSE 0 END AS AtendeSemAdicao   -- se ja atende o minimo do item
		  FROM SugestaoPedido AS SP WITH (NOLOCK)
			   INNER JOIN ItemDetalhe AS ID WITH (NOLOCK)
					   ON SP.IDItemDetalhePedido = ID.IDItemDetalhe											
		 WHERE SP.IdLoja = ISNULL(@idLoja, SP.IdLoja)
		   AND SP.dtPedido = ISNULL(@DataPedido, SP.dtPedido)
		   AND SP.idFornecedorParametro = ISNULL(@idFornecedorParametro, SP.idFornecedorParametro)
		   AND SP.vlTipoReabastecimento NOT IN (3, 33, 94)
	), CalculoShelfLifeForecast AS (
		-- Todos os itens onde a sugestao não está acima do vlMinimo e que podem ter um ajuste (adicao no qtdPackCompra) pra tentar atender o minimo do item
		-- determina qual o maior pedido q atende o forecast (o valor final precisa ser menor ou igual a este para setar blAtendePedidoMinimoItem=1)
		SELECT *
			 , CASE WHEN @blAdicionaPack = 1 AND II.vlForecastMedio > 0 AND II.qtdPackCompra > 0 THEN CEILING(((((II.vlShelfLife * II.vlForecastMedio) - II.vlEstoque) / II.vlFatorConversao) / II.qtVendorPackage) - 1) ELSE NULL END AS qtdPackCompraForecast
		  FROM Itens II
		 WHERE AtendeSemAdicao = 0
	), Minimo AS (
		-- Determina o qtdPackCompra ajustado (o menor entre [o minimo do item OU o maior qtdPackCompra que atende ao shelflife]) e verifica se este valor atende o minimo E o shelflife
		SELECT *
			 , CASE WHEN vlMinimo <= qtdPackCompraForecast THEN vlMinimo ELSE qtdPackCompraForecast END AS qtdPackCompraAjustado
			 , CASE WHEN vlMinimo <= qtdPackCompraForecast AND @blAdicionaPack = 1 THEN 1 ELSE 0 END AS AjustadoAtende
		  FROM CalculoShelfLifeForecast
		UNION ALL
		-- Itens que já atendem o pedido minimo do item mas que o qtdPackCompra não é multiplo do minimo e portanto precisam de arredondamento
		SELECT *
			 , NULL AS qtdPackCompraForecast
			 , qtdPackCompra AS qtdPackCompraAjustado
			 , 1 AS AjustadoAtende
		  FROM Itens II
		 WHERE AtendeSemAdicao = 1 AND RequerMultiploMinimo = 1 AND AtendeMultiploMinimo = 0
	), Arredondamentos AS (
		-- Itens DSD Fixo cujo qtdPackCompraAjustado não é multiplo do minimo precisam arredondar,
		-- entao procuramos o valor arredondado multiplo do minimo acima e abaixo do ajustado
		SELECT *
			 , CASE WHEN vlMinimo <> 0 THEN CEILING(qtdPackCompraAjustado / vlMinimo) * vlMinimo ELSE qtdPackCompraAjustado END AS PraCima
			 , CASE WHEN vlMinimo <> 0 THEN FLOOR(qtdPackCompraAjustado / vlMinimo) * vlMinimo ELSE qtdPackCompraAjustado END AS PraBaixo
		  FROM Minimo
		 WHERE RequerMultiploMinimo = 1 AND AtendeMultiploMinimo = 0 AND AjustadoAtende = 1
	), ComArredondamento AS (
		-- Verificamos qual dos valores atende o minimo do item e o shelflife:
		-- 1. O ajustado arredondado pra cima conforme multiplo do minimo, se este valor atende ao shelflife
		-- 1. O ajustado arredondado pra baixo conforme multiplo do minimo, se este valor atende ao shelflife OU se originalmente o valor setado ja atendia o minimo do item mas precisava de arredondamento
		SELECT *
			 , CASE WHEN (((AA.vlEstoque + ((AA.PraCima + 1) * AA.qtVendorPackage * AA.vlFatorConversao)) / AA.vlForecastMedio) < AA.vlShelfLife) AND AA.PraCima >= AA.vlMinimo AND @blAdicionaPack = 1 THEN 1 ELSE 0 END AS TetoAtende
			 , CASE WHEN (((AA.vlEstoque + ((AA.PraBaixo + 1) * AA.qtVendorPackage * AA.vlFatorConversao)) / AA.vlForecastMedio) < AA.vlShelfLife) AND AA.PraBaixo >= AA.vlMinimo AND @blAdicionaPack = 1 THEN 1 WHEN RequerMultiploMinimo = 1 AND AtendeSemAdicao = 1 THEN 1 ELSE 0 END AS ChaoAtende
		  FROM Arredondamentos AA
	), Resultado AS (
		-- Os itens que ja estavam ok e nao fizemos nada
		SELECT *, NULL AS qtdPackCompraForecast, NULL AS qtdPackCompraAjustado, NULL AS AjustadoAtende, NULL AS PraCima, NULL AS PraBaixo, NULL AS TetoAtende, NULL AS ChaoAtende
		  FROM Itens II
		 WHERE AtendeSemAdicao = 1 AND (RequerMultiploMinimo = 0 OR (RequerMultiploMinimo = 1 AND AtendeMultiploMinimo = 1))
		UNION ALL
		-- os itens q nao estavam ok, foram ajustados, e requerem arredondamento de multiplo do minimo
		SELECT *
		  FROM ComArredondamento
		UNION ALL
		-- os itens q nao estavam ok, todos os outros cenarios
		SELECT *, NULL AS PraCima, NULL AS PraBaixo, NULL AS TetoAtende, NULL AS ChaoAtende
		  FROM Minimo
		 WHERE RequerMultiploMinimo = 0 OR (RequerMultiploMinimo = 1 AND (AtendeMultiploMinimo = 1 OR AjustadoAtende = 0))
	)
	INSERT 
	  INTO #TmpMinimoItem
	SELECT *
	  FROM Resultado

	UPDATE SP  -- Atualiza as sugestoes
	   SET SP.qtdPackCompra = CASE WHEN RR.RequerMultiploMinimo = 1 AND RR.TetoAtende = 1 THEN RR.PraCima
								   WHEN RR.RequerMultiploMinimo = 1 AND RR.ChaoAtende = 1 THEN RR.PraBaixo
								   WHEN RR.RequerMultiploMinimo = 0 AND RR.AjustadoAtende = 1 THEN RR.qtdPackCompraAjustado
								   ELSE RR.qtdPackCompra END
		 , SP.blAtendePedidoMinimoItem = CASE WHEN RR.RequerMultiploMinimo = 1 AND RR.TetoAtende = 1 THEN 1
											  WHEN RR.RequerMultiploMinimo = 1 AND RR.ChaoAtende = 1 THEN 1
											  WHEN RR.RequerMultiploMinimo = 0 AND RR.AjustadoAtende = 1 THEN 1
											  ELSE RR.AtendeSemAdicao END
		 , SP.blAtendePedidoMinimo = CASE WHEN RR.TetoAtende = 1 OR RR.ChaoAtende = 1 OR RR.AjustadoAtende = 1 OR RR.AtendeSemAdicao = 1 THEN SP.blAtendePedidoMinimo ELSE 0 END
	  FROM SugestaoPedido SP
		   INNER JOIN #TmpMinimoItem RR
				   ON SP.IDSugestaoPedido = RR.IDSugestaoPedido

	--FIM PEDIDO MINIMO DO ITEM

	DECLARE  @vlPedidoMinimo DECIMAL(15, 2)
			,@vlPedido DECIMAL(15, 2) -- este é o vlPedido do vendor para a loja informada nos itens que não são cross docking
			,@tpPedidoMinimo CHAR(1)
			,@blAtendePedidoMinimo BIT
			,@maxShelfLifeAtendido BIT
			,@idSugestaoPedido BIGINT
			,@vlShelfLife NUMERIC(5)
			,@vlEstoque DECIMAL(15, 3)
			,@vlForecastMedio DECIMAL(15, 3)
			,@vlFatorConversao FLOAT
			,@qtVendorPackage INT
			,@vlModulo DECIMAL(15, 3)
			,@qtPackCompra INT
			,@vlCustoItem DECIMAL(15, 3)
			,@qtDiasEstoque INT
			,@tpCaixaFornecedor CHAR(1)
			,@vlPesoLiquido DECIMAL(15, 4)
			,@cdConvertido BIT
			,@AbriuTrn BIT
			,@idCD INT
			,@vlTipoReabastecimento  INT

	SET @AbriuTrn = 0;

	IF (@@TRANCOUNT = 0)
		BEGIN
			BEGIN TRAN

			SET @AbriuTrn = 1
		END

	-- configuracao do vendor
	SELECT   @vlPedidoMinimo = FP.vlValorMinimo
			,@tpPedidoMinimo = FP.tpPedidoMinimo
		FROM  FornecedorParametro FP WITH (NOLOCK)
		WHERE  FP.IDFornecedorParametro = @idFornecedorParametro

	SELECT @vlPedido = sum(CASE 
				WHEN @tpPedidoMinimo = '$'
					THEN SP.qtdPackCompra * SP.vlFatorConversao * SP.qtVendorPackage * CASE ISNULL(ES.vlCustoContabilAtual, 0)
							WHEN 0
								THEN ISNULL(ES.vlCustoCadastroAtual, 0)
							ELSE ISNULL(ES.vlCustoContabilAtual, 0)
							END
				ELSE SP.qtdPackCompra
				END)			
	FROM SugestaoPedido SP WITH (NOLOCK)
	LEFT JOIN Estoque ES WITH (NOLOCK)
		ON ES.IDLoja = SP.IdLoja
			AND ES.IDItemDetalhe = SP.IDItemDetalheSugestao
			AND ES.dtRecebimento = (
				SELECT MAX(E.dtRecebimento)
				FROM Estoque E WITH (NOLOCK)
				WHERE E.IDItemDetalhe = ES.IDItemDetalhe
					AND E.IDLoja = ES.IDLoja
				)
	JOIN CD WITH (NOLOCK)
		ON CD.idCD = SP.idCD
	WHERE SP.dtPedido = @DataPedido
		AND SP.IdLoja = @idLoja
		AND SP.IDFornecedorParametro = @idFornecedorParametro
		AND (
			SP.vlTipoReabastecimento IN (7, 37)
			OR (
				CD.blConvertido = 1
				AND SP.vlTipoReabastecimento = 97
				)
			)
		AND SP.qtdPackCompra > 0
		AND SP.blAtendePedidoMinimoItem = 1			

	-- lida com blAtendePedidoMinimo em todas as sugestoes de itens nao-cross-dock da loja e vendor informados
	--print '@vlPedido ' + convert(varchar, @vlPedido)
	--print '@vlPedidoMinimo ' + convert(varchar, @vlPedidoMinimo)

	IF @vlPedido >= @vlPedidoMinimo
			UPDATE SP
			SET SP.blAtendePedidoMinimo = 1
			FROM SugestaoPedido SP
			JOIN CD WITH (NOLOCK)
				ON CD.idCD = SP.idCD
			WHERE SP.dtPedido = @DataPedido
			AND SP.IdLoja = @idLoja
			AND SP.IDFornecedorParametro = @idFornecedorParametro
			AND (
				SP.vlTipoReabastecimento IN (7, 37)
				OR (
					CD.blConvertido = 1
					AND SP.vlTipoReabastecimento = 97
					)
				)
			AND SP.blAtendePedidoMinimoItem = 1
			--AND SP.qtdPackCompra > 0 	--retirado pedido Vinicius 05/08
			--AND SP.vlForecastMedio > 0  --retirado pedido Vinicius 28/07
			--AND SP.cdOrigemCalculo = 'S'  --retirado pedido Vinicius 28/07
											
	ELSE
	BEGIN
		UPDATE SP
		SET blAtendePedidoMinimo = 0
		FROM SugestaoPedido SP
		JOIN CD WITH (NOLOCK)
			ON CD.idCD = SP.idCD
		WHERE dtPedido = @DataPedido
			AND IdLoja = @idLoja
			AND IDFornecedorParametro = @idFornecedorParametro
			AND (
				vlTipoReabastecimento IN (7, 37)
				OR (
					CD.blConvertido = 1
					AND SP.vlTipoReabastecimento = 97
					)
				)
			AND qtdPackCompra > 0
			--AND vlForecastMedio > 0	--retirado pedido Vinicius 28/07
			--AND cdOrigemCalculo = 'S'	--retirado pedido Vinicius 28/07
												
		IF @blAdicionaPack = 1
		BEGIN
			SAVE TRANSACTION AntesDoAcrescimo -- essa transaction vai sofrer rollback caso saia do loop sem atender o minimo
			--print 'vai preparar'
			-- Habilita para a iteração todos os itens passivos de adição no pack. (itens em aberto)
			UPDATE SP
			SET SP.blAtendePedidoMinimo = 1
			FROM SugestaoPedido SP WITH (NOLOCK)
			JOIN CD WITH (NOLOCK)
				ON CD.idCD = SP.idCD
			JOIN Loja L WITH (NOLOCK)
				ON L.IDLoja = SP.IdLoja
			JOIN ItemDetalhe ID WITH (NOLOCK)
				ON ID.IDItemDetalhe = SP.IDItemDetalhePedido
			CROSS APPLY dbo.fnBuscaGrade(L.IDBandeira, ID.IDDepartamento, SP.IDLoja) GS
			WHERE SP.dtPedido = @DataPedido
				AND SP.IdLoja = @idLoja
				AND SP.IDFornecedorParametro = @idFornecedorParametro
				AND (
					SP.vlTipoReabastecimento IN (7, 37)
					OR (
						CD.blConvertido = 1
						AND SP.vlTipoReabastecimento = 97
						)
					)
				AND SP.qtdPackCompra > 0
				AND SP.vlForecastMedio > 0
				-- AND SP.cdOrigemCalculo = 'S'	--retirado pedido Vinicius 28/07
				AND SP.blAtendePedidoMinimo = 0
				AND SP.blAtendePedidoMinimoItem = 1
			--print 'o valor acima é o numero de itens que podem entrar na adicao de pack'

			DECLARE @RequerMultiploMinimo BIT, @vlMinimoItem NUMERIC(9,2);

			DECLARE Pedidos CURSOR STATIC FORWARD_ONLY READ_ONLY
			FOR
			SELECT SP.IDSugestaoPedido
				,SP.vlshelflife
				,SP.vlestoque
				,SP.vlforecastmedio
				,SP.vlfatorconversao
				,SP.qtvendorpackage
				,SP.vlmodulo
				,SP.qtdpackcompra
				,CASE ISNULL(ES.vlCustoContabilAtual, 0)
					WHEN 0
						THEN ISNULL(ES.vlCustoCadastroAtual, 0)
					ELSE ISNULL(ES.vlCustoContabilAtual, 0)
					END vlCustoItem
				,CD.blConvertido
				,CASE 
					WHEN ISNULL(SP.vlPesoLiquido, 0) > 1 THEN ROUND(SP.vlPesoLiquido, 0) 
					WHEN ISNULL(SP.vlPesoLiquido, 0) <= 1 THEN 1
					END AS vlPesoLiquido
				,SP.tpCaixaFornecedor
				,SP.vlTipoReabastecimento
				,ISNULL(MI.RequerMultiploMinimo,0)
				,CASE WHEN MI.vlMinimo < 1 THEN 1 ELSE MI.vlMinimo END
			FROM SugestaoPedido SP WITH (NOLOCK)
			LEFT JOIN Estoque ES WITH (NOLOCK)
				ON ES.IDLoja = SP.IdLoja
					AND ES.IDItemDetalhe = SP.IDItemDetalheSugestao
					AND ES.dtRecebimento = (
						SELECT MAX(E.dtRecebimento)
						FROM Estoque E WITH (NOLOCK)
						WHERE E.IDItemDetalhe = ES.IDItemDetalhe
							AND E.IDLoja = ES.IDLoja
						)
			JOIN CD WITH (NOLOCK)
				ON CD.idCD = SP.idCD
			LEFT JOIN #TmpMinimoItem MI
			       ON MI.IDSugestaoPedido = SP.IDSugestaoPedido
			WHERE SP.dtPedido = @DataPedido
				AND SP.IdLoja = @idLoja
				AND SP.IDFornecedorParametro = @idFornecedorParametro
				AND (
					SP.vlTipoReabastecimento IN (7, 37)
					OR (
						CD.blConvertido = 1
						AND SP.vlTipoReabastecimento = 97
						)
					)
				AND SP.qtdPackCompra > 0
				AND SP.vlForecastMedio > 0
				--AND SP.cdOrigemCalculo = 'S'	--retirado pedido Vinicius 28/07
				AND SP.blAtendePedidoMinimo = 1
				AND SP.blAtendePedidoMinimoItem = 1
											
			ORDER BY SP.vlForecastMedio DESC, SP.vlShelfLife DESC

			SET @blAtendePedidoMinimo = 0
			SET @maxShelfLifeAtendido = 0
			--print 'print 3'
											

			WHILE @blAtendePedidoMinimo = 0
				AND @maxShelfLifeAtendido = 0
			BEGIN
				OPEN Pedidos
											
				FETCH NEXT FROM Pedidos
				INTO @idSugestaoPedido
					,@vlShelfLife
					,@vlEstoque
					,@vlForecastMedio
					,@vlFatorConversao
					,@qtVendorPackage
					,@vlModulo
					,@qtPackCompra
					,@vlCustoItem
					,@cdConvertido
					,@vlPesoLiquido
					,@tpCaixaFornecedor
					,@vlTipoReabastecimento
					,@RequerMultiploMinimo
					,@vlMinimoItem

				--print 'print 2'
				--print @idSugestaoPedido
				--print '@@FETCH_STATUS ' + convert(varchar,@@FETCH_STATUS)

				--print 'vai iniciar loop interno'
				IF @@FETCH_STATUS != 0
					SET @maxShelfLifeAtendido = 1
				ELSE
					WHILE @@FETCH_STATUS = 0
						AND @blAtendePedidoMinimo = 0
					BEGIN
						--print 'loop interno'
						--print @vlPedido
						--print @qtDiasEstoque
						--print @vlShelfLife
						--print @vlEstoque
						--print @qtPackCompra 
						--print @vlFatorConversao
						--print @vlForecastMedio
						--print @vlPesoLiquido
						--print @tpPedidoMinimo
						--print @vlFatorConversao
						--print @qtVendorPackage
						--print @vlCustoItem
						--print '-'
						--Se CD não é convertido e não é um item DSD
						IF @cdConvertido = 0 and @vlTipoReabastecimento not in (7,37,97)
													
						BEGIN
							--print 'if 0'
							-- Se é peso variável
							IF @qtVendorPackage = 1 
							BEGIN
								--print 'é 1'
								-- Adiciona uma quantidade do peso bruto ao packcompra da sugestão
								SET @qtPackCompra += @vlModulo
								SET @qtDiasEstoque = CEILING((@vlEstoque + (@qtPackCompra * @vlFatorConversao)) / @vlForecastMedio)
								-- Valida qtde de dias de estoque está dentro do limite de shelflife
								IF @qtDiasEstoque < @vlShelfLife
								BEGIN
									--Atualizar valor total do pedido do vendor
									SET @vlPedido = @vlPedido + (
											(
												@vlModulo * CASE @tpPedidoMinimo
													WHEN '$'
														THEN @vlFatorConversao * @qtVendorPackage * @vlCustoItem
													ELSE 1
													END))
								END
							END
							-- Se é peso fixo @qtVendorPackage <> 1
							ELSE 
							BEGIN
								--print 'é outro que 1'
								-- Adiciona quantidade 1 ao packcompra da sugestão
								SET @qtPackCompra += 1
								SET @qtDiasEstoque = CEILING(@vlEstoque + (@qtPackCompra * @qtVendorPackage * @vlFatorConversao)) / @vlForecastMedio
								-- Valida qtde de dias de estoque está dentro do limite de shelflife
								IF @qtDiasEstoque < @vlShelfLife
								BEGIN
									--Atualizar valor total do pedido do vendor
									SET @vlPedido = @vlPedido + (
											CASE @tpPedidoMinimo
												WHEN '$'
													THEN @vlFatorConversao * @qtVendorPackage * @vlCustoItem 
												ELSE 1
												END )
								END 
							END
						END
						--Se CD convertido ou é um item DSD
						ELSE 
						BEGIN
							--print 'if 1'
							-- Se é peso variável
							IF @tpCaixaFornecedor = 'V'
							BEGIN
								--print 'é V'
								--print 'vai somar '
								--print @vlPesoLiquido
								-- Adiciona uma quantidade do peso líquido ao packcompra da sugestão
								SET @qtPackCompra += @vlPesoLiquido
								SET @qtDiasEstoque = CEILING((@vlEstoque + (@qtPackCompra * @vlFatorConversao)) / @vlForecastMedio)
								-- Valida qtde de dias de estoque está dentro do limite de shelflife
								-- Se chegar ao máximo do shelflife não adiciona mais quantidade para a sugestão
								IF @qtDiasEstoque < @vlShelfLife
									--Atualizar valor total do pedido do vendor
									SET @vlPedido = @vlPedido + (
											@vlPesoLiquido * CASE @tpPedidoMinimo
												WHEN '$'
													THEN @vlFatorConversao * @qtVendorPackage * @vlCustoItem
												ELSE 1
												END
											)
							END
							-- Se é peso fixo @tpCaixaFornecedor <> 'V' (='F')
							ELSE
							BEGIN
								--print 'é outro'
								-- Adiciona quantidade 1 ao packcompra da sugestão
								SET @qtPackCompra += CASE WHEN @tpCaixaFornecedor = 'F' THEN @vlMinimoItem ELSE 1 END
								SET @qtDiasEstoque = CEILING(@vlEstoque + (@qtPackCompra * @qtVendorPackage * @vlFatorConversao)) / @vlForecastMedio
								-- Valida qtde de dias de estoque está dentro do limite de shelflife
								IF @qtDiasEstoque < @vlShelfLife
								BEGIN
									SET @vlPedido = @vlPedido + ( CASE @tpPedidoMinimo
											WHEN '$'
												THEN @vlFatorConversao * @qtVendorPackage * @vlCustoItem
											ELSE 
												CASE WHEN @tpCaixaFornecedor = 'F' THEN @vlMinimoItem ELSE 1 END
											END )
								END
							END
						END

						--print 'vlPedido fica'
						--print @vlPedido
						--print @qtDiasEstoque
						--print @vlShelfLife
						--print @vlEstoque
						--print 'qtdPackCompra=' + convert(varchar, @qtPackCompra )
						--print @vlFatorConversao
						--print @vlForecastMedio
						--print @vlPesoLiquido
						--print @tpPedidoMinimo
						--print @vlFatorConversao
						--print @qtVendorPackage
						--print @vlCustoItem
						--print 'vlMinimo'
						--print @vlMinimoItem
						--print @RequerMultiploMinimo
						--print '-'
						--Valida se com a adição do pack o total do pedido do vendor atinge o mínimo
						IF @vlPedido >= @vlPedidoMinimo
							SET @blAtendePedidoMinimo = 1

						--Se o shelflife não foi atingido ainda atualiza a sugestão de compra com a quantidade adicionada
						IF @qtDiasEstoque < @vlShelfLife
							BEGIN
							UPDATE SugestaoPedido
							SET vlQtdDiasEstoque = @qtDiasEstoque
								,qtdPackCompra = @qtPackCompra
							WHERE IDSugestaoPedido = @idSugestaoPedido
							END

						ELSE
							BEGIN
							UPDATE SugestaoPedido
							SET blAtendePedidoMinimo = 0
							WHERE IDSugestaoPedido = @idSugestaoPedido
							END

						FETCH NEXT FROM Pedidos
						INTO @idSugestaoPedido
							,@vlShelfLife
							,@vlEstoque
							,@vlForecastMedio
							,@vlFatorConversao
							,@qtVendorPackage
							,@vlModulo
							,@qtPackCompra
							,@vlCustoItem
							,@cdConvertido
							,@vlPesoLiquido
							,@tpCaixaFornecedor
							,@vlTipoReabastecimento
							,@RequerMultiploMinimo
							,@vlMinimoItem

					END

				CLOSE Pedidos
			END

			DEALLOCATE Pedidos

			IF (@blAtendePedidoMinimo = 0)
			BEGIN
				ROLLBACK TRANSACTION AntesDoAcrescimo -- mesmo incrementando, nao atingiu o minimo; descarta todas as alteracoes, voltando para o estado em que estava no inicio do loop
			END 
										
										
			UPDATE SP
			SET blAtendePedidoMinimo = @blAtendePedidoMinimo
			FROM SugestaoPedido SP
			JOIN CD WITH (NOLOCK)
				ON CD.idCD = SP.idCD
			WHERE dtPedido = @DataPedido
				AND IdLoja = @idLoja
				AND IDFornecedorParametro = @idFornecedorParametro
				AND (
					vlTipoReabastecimento IN (7, 37)
					OR (
						CD.blConvertido = 1
						AND SP.vlTipoReabastecimento = 97
						)
					)
				AND qtdPackCompra > 0
				AND vlForecastMedio > 0
				--AND cdOrigemCalculo = 'S'	--retirado pedido Vinicius 28/07
												
		END
	END

	IF OBJECT_ID('Tempdb..#TmpMinimoItem') IS NOT NULL
	BEGIN
		DROP TABLE #TmpMinimoItem
	END

	IF (@AbriuTrn = 1)
	BEGIN
		COMMIT TRAN
	END

END
			]]>
		</sql>
		<rollback>
			<sql stripComments="false" endDelimiter="">
				<![CDATA[ 

ALTER PROCEDURE [dbo].[PRC_ATENDEPEDIDOMINIMO] 	 @idLoja INT
                                                ,@idFornecedorParametro BIGINT
                                                ,@DataPedido DATE
                                                ,@blAdicionaPack BIT = 1
AS
BEGIN
	--PEDIDO MINIMO DO ITEM
	IF OBJECT_ID('Tempdb..#TmpMinimoItem') IS NOT NULL 
	BEGIN
		DROP TABLE #TmpMinimoItem
	END

	CREATE TABLE #TmpMinimoItem ( IDSugestaoPedido INT, qtdPackCompra INT, blAtendePedidoMinimoItem BIT, vlMinimo NUMERIC(9,2), vlEstoque NUMERIC(11,3),
								qtVendorPackage INT, vlFatorConversao FLOAT, vlForecastMedio NUMERIC(11,3), vlShelflife INT, vlTipoReabastecimento SMALLINT,
								tpCaixaFornecedor CHAR(1), RequerMultiploMinimo BIT, AtendeMultiploMinimo BIT, AtendeSemAdicao BIT, 
								qtdPackCompraForecast INT, qtdPackCompraAjustado INT, AjustadoAtende BIT, PraCima INT, PraBaixo INT,
								TetoAtende BIT, ChaoAtende BIT);
	WITH Itens AS (
		-- Determina todos os itens que devem ser validados em relacao ao requisito do pedido minimo do item
		SELECT SP.IDSugestaoPedido, ISNULL(SP.qtdPackCompra, 0) AS qtdPackCompra, SP.blAtendePedidoMinimoItem, ISNULL(ID.vlMinimo, 0) AS vlMinimo
			 , SP.vlEstoque, SP.qtVendorPackage, SP.vlFatorConversao, ISNULL(SP.vlForecastMedio, 0) AS vlForecastMedio, SP.vlShelfLife
			 , SP.vlTipoReabastecimento, SP.tpCaixaFornecedor
			 , CASE WHEN ISNULL(SP.tpCaixaFornecedor, '') = 'F' AND SP.vlTipoReabastecimento IN (7,37,97) AND SP.vlForecastMedio > 0 THEN 1 ELSE 0 END AS RequerMultiploMinimo  -- DSD Fixo precisa arredondar conforme multiplo do minimo do item
			 , CASE WHEN qtdPackCompra % vlMinimo = 0 AND SP.vlTipoReabastecimento IN (7,37,97) AND SP.vlForecastMedio > 0 THEN 1 ELSE 0 END AS AtendeMultiploMinimo            -- se já é multiplo do minimo do item
			 , CASE WHEN SP.qtdPackCompra > 0 AND SP.qtdPackCompra >= ISNULL(ID.vlMinimo, 0) THEN 1 ELSE 0 END AS AtendeSemAdicao   -- se ja atende o minimo do item
		  FROM SugestaoPedido AS SP WITH (NOLOCK)
			   INNER JOIN ItemDetalhe AS ID WITH (NOLOCK)
					   ON SP.IDItemDetalhePedido = ID.IDItemDetalhe											
		 WHERE SP.IdLoja = ISNULL(@idLoja, SP.IdLoja)
		   AND SP.dtPedido = ISNULL(@DataPedido, SP.dtPedido)
		   AND SP.idFornecedorParametro = ISNULL(@idFornecedorParametro, SP.idFornecedorParametro)
		   AND SP.vlTipoReabastecimento NOT IN (3, 33, 94)
	), CalculoShelfLifeForecast AS (
		-- Todos os itens onde a sugestao não está acima do vlMinimo e que podem ter um ajuste (adicao no qtdPackCompra) pra tentar atender o minimo do item
		-- determina qual o maior pedido q atende o forecast (o valor final precisa ser menor ou igual a este para setar blAtendePedidoMinimoItem=1)
		SELECT *
			 , CASE WHEN @blAdicionaPack = 1 AND II.vlForecastMedio > 0 AND II.qtdPackCompra > 0 THEN CEILING(((((II.vlShelfLife * II.vlForecastMedio) - II.vlEstoque) / II.vlFatorConversao) / II.qtVendorPackage) - 1) ELSE NULL END AS qtdPackCompraForecast
		  FROM Itens II
		 WHERE AtendeSemAdicao = 0
	), Minimo AS (
		-- Determina o qtdPackCompra ajustado (o menor entre [o minimo do item OU o maior qtdPackCompra que atende ao shelflife]) e verifica se este valor atende o minimo E o shelflife
		SELECT *
			 , CASE WHEN vlMinimo <= qtdPackCompraForecast THEN vlMinimo ELSE qtdPackCompraForecast END AS qtdPackCompraAjustado
			 , CASE WHEN vlMinimo <= qtdPackCompraForecast AND @blAdicionaPack = 1 THEN 1 ELSE 0 END AS AjustadoAtende
		  FROM CalculoShelfLifeForecast
		UNION ALL
		-- Itens que já atendem o pedido minimo do item mas que o qtdPackCompra não é multiplo do minimo e portanto precisam de arredondamento
		SELECT *
			 , NULL AS qtdPackCompraForecast
			 , qtdPackCompra AS qtdPackCompraAjustado
			 , 1 AS AjustadoAtende
		  FROM Itens II
		 WHERE AtendeSemAdicao = 1 AND RequerMultiploMinimo = 1 AND AtendeMultiploMinimo = 0
	), Arredondamentos AS (
		-- Itens DSD Fixo cujo qtdPackCompraAjustado não é multiplo do minimo precisam arredondar,
		-- entao procuramos o valor arredondado multiplo do minimo acima e abaixo do ajustado
		SELECT *
			 , CASE WHEN vlMinimo <> 0 THEN CEILING(qtdPackCompraAjustado / vlMinimo) * vlMinimo ELSE qtdPackCompraAjustado END AS PraCima
			 , CASE WHEN vlMinimo <> 0 THEN FLOOR(qtdPackCompraAjustado / vlMinimo) * vlMinimo ELSE qtdPackCompraAjustado END AS PraBaixo
		  FROM Minimo
		 WHERE RequerMultiploMinimo = 1 AND AtendeMultiploMinimo = 0 AND AjustadoAtende = 1
	), ComArredondamento AS (
		-- Verificamos qual dos valores atende o minimo do item e o shelflife:
		-- 1. O ajustado arredondado pra cima conforme multiplo do minimo, se este valor atende ao shelflife
		-- 1. O ajustado arredondado pra baixo conforme multiplo do minimo, se este valor atende ao shelflife OU se originalmente o valor setado ja atendia o minimo do item mas precisava de arredondamento
		SELECT *
			 , CASE WHEN (((AA.vlEstoque + ((AA.PraCima + 1) * AA.qtVendorPackage * AA.vlFatorConversao)) / AA.vlForecastMedio) < AA.vlShelfLife) AND AA.PraCima >= AA.vlMinimo AND @blAdicionaPack = 1 THEN 1 ELSE 0 END AS TetoAtende
			 , CASE WHEN (((AA.vlEstoque + ((AA.PraBaixo + 1) * AA.qtVendorPackage * AA.vlFatorConversao)) / AA.vlForecastMedio) < AA.vlShelfLife) AND AA.PraBaixo >= AA.vlMinimo AND @blAdicionaPack = 1 THEN 1 WHEN RequerMultiploMinimo = 1 AND AtendeSemAdicao = 1 THEN 1 ELSE 0 END AS ChaoAtende
		  FROM Arredondamentos AA
	), Resultado AS (
		-- Os itens que ja estavam ok e nao fizemos nada
		SELECT *, NULL AS qtdPackCompraForecast, NULL AS qtdPackCompraAjustado, NULL AS AjustadoAtende, NULL AS PraCima, NULL AS PraBaixo, NULL AS TetoAtende, NULL AS ChaoAtende
		  FROM Itens II
		 WHERE AtendeSemAdicao = 1 AND (RequerMultiploMinimo = 0 OR (RequerMultiploMinimo = 1 AND AtendeMultiploMinimo = 1))
		UNION ALL
		-- os itens q nao estavam ok, foram ajustados, e requerem arredondamento de multiplo do minimo
		SELECT *
		  FROM ComArredondamento
		UNION ALL
		-- os itens q nao estavam ok, todos os outros cenarios
		SELECT *, NULL AS PraCima, NULL AS PraBaixo, NULL AS TetoAtende, NULL AS ChaoAtende
		  FROM Minimo
		 WHERE RequerMultiploMinimo = 0 OR (RequerMultiploMinimo = 1 AND (AtendeMultiploMinimo = 1 OR AjustadoAtende = 0))
	)
	INSERT 
	  INTO #TmpMinimoItem
	SELECT *
	  FROM Resultado

	UPDATE SP  -- Atualiza as sugestoes
	   SET SP.qtdPackCompra = CASE WHEN RR.RequerMultiploMinimo = 1 AND RR.TetoAtende = 1 THEN RR.PraCima
								   WHEN RR.RequerMultiploMinimo = 1 AND RR.ChaoAtende = 1 THEN RR.PraBaixo
								   WHEN RR.RequerMultiploMinimo = 0 AND RR.AjustadoAtende = 1 THEN RR.qtdPackCompraAjustado
								   ELSE RR.qtdPackCompra END
		 , SP.blAtendePedidoMinimoItem = CASE WHEN RR.RequerMultiploMinimo = 1 AND RR.TetoAtende = 1 THEN 1
											  WHEN RR.RequerMultiploMinimo = 1 AND RR.ChaoAtende = 1 THEN 1
											  WHEN RR.RequerMultiploMinimo = 0 AND RR.AjustadoAtende = 1 THEN 1
											  ELSE RR.AtendeSemAdicao END
		 , SP.blAtendePedidoMinimo = CASE WHEN RR.TetoAtende = 1 OR RR.ChaoAtende = 1 OR RR.AjustadoAtende = 1 OR RR.AtendeSemAdicao = 1 THEN SP.blAtendePedidoMinimo ELSE 0 END
	  FROM SugestaoPedido SP
		   INNER JOIN #TmpMinimoItem RR
				   ON SP.IDSugestaoPedido = RR.IDSugestaoPedido

	--FIM PEDIDO MINIMO DO ITEM

	DECLARE  @vlPedidoMinimo DECIMAL(15, 2)
			,@vlPedido DECIMAL(15, 2) -- este é o vlPedido do vendor para a loja informada nos itens que não são cross docking
			,@tpPedidoMinimo CHAR(1)
			,@blAtendePedidoMinimo BIT
			,@maxShelfLifeAtendido BIT
			,@idSugestaoPedido BIGINT
			,@vlShelfLife NUMERIC(5)
			,@vlEstoque DECIMAL(15, 3)
			,@vlForecastMedio DECIMAL(15, 3)
			,@vlFatorConversao FLOAT
			,@qtVendorPackage INT
			,@vlModulo DECIMAL(15, 3)
			,@qtPackCompra INT
			,@vlCustoItem DECIMAL(15, 3)
			,@qtDiasEstoque INT
			,@tpCaixaFornecedor CHAR(1)
			,@vlPesoLiquido DECIMAL(15, 4)
			,@cdConvertido BIT
			,@AbriuTrn BIT
			,@idCD INT
			,@vlTipoReabastecimento  INT

	SET @AbriuTrn = 0;

	IF (@@TRANCOUNT = 0)
		BEGIN
			BEGIN TRAN

			SET @AbriuTrn = 1
		END

	-- configuracao do vendor
	SELECT   @vlPedidoMinimo = FP.vlValorMinimo
			,@tpPedidoMinimo = FP.tpPedidoMinimo
		FROM  FornecedorParametro FP WITH (NOLOCK)
		WHERE  FP.IDFornecedorParametro = @idFornecedorParametro

	SELECT @vlPedido = sum(CASE 
				WHEN @tpPedidoMinimo = '$'
					THEN SP.qtdPackCompra * SP.vlFatorConversao * SP.qtVendorPackage * CASE ISNULL(ES.vlCustoContabilAtual, 0)
							WHEN 0
								THEN ISNULL(ES.vlCustoCadastroAtual, 0)
							ELSE ISNULL(ES.vlCustoContabilAtual, 0)
							END
				ELSE SP.qtdPackCompra
				END)			
	FROM SugestaoPedido SP WITH (NOLOCK)
	LEFT JOIN Estoque ES WITH (NOLOCK)
		ON ES.IDLoja = SP.IdLoja
			AND ES.IDItemDetalhe = SP.IDItemDetalheSugestao
			AND ES.dtRecebimento = (
				SELECT MAX(E.dtRecebimento)
				FROM Estoque E WITH (NOLOCK)
				WHERE E.IDItemDetalhe = ES.IDItemDetalhe
					AND E.IDLoja = ES.IDLoja
				)
	JOIN CD WITH (NOLOCK)
		ON CD.idCD = SP.idCD
	WHERE SP.dtPedido = @DataPedido
		AND SP.IdLoja = @idLoja
		AND SP.IDFornecedorParametro = @idFornecedorParametro
		AND (
			SP.vlTipoReabastecimento IN (7, 37)
			OR (
				CD.blConvertido = 1
				AND SP.vlTipoReabastecimento = 97
				)
			)
		AND SP.qtdPackCompra > 0
		AND SP.blAtendePedidoMinimoItem = 1			

	-- lida com blAtendePedidoMinimo em todas as sugestoes de itens nao-cross-dock da loja e vendor informados
	--print '@vlPedido ' + convert(varchar, @vlPedido)
	--print '@vlPedidoMinimo ' + convert(varchar, @vlPedidoMinimo)

	IF @vlPedido >= @vlPedidoMinimo
			UPDATE SP
			SET SP.blAtendePedidoMinimo = 1
			FROM SugestaoPedido SP
			JOIN CD WITH (NOLOCK)
				ON CD.idCD = SP.idCD
			WHERE SP.dtPedido = @DataPedido
			AND SP.IdLoja = @idLoja
			AND SP.IDFornecedorParametro = @idFornecedorParametro
			AND (
				SP.vlTipoReabastecimento IN (7, 37)
				OR (
					CD.blConvertido = 1
					AND SP.vlTipoReabastecimento = 97
					)
				)
			AND SP.blAtendePedidoMinimoItem = 1
			--AND SP.qtdPackCompra > 0 	--retirado pedido Vinicius 05/08
			--AND SP.vlForecastMedio > 0  --retirado pedido Vinicius 28/07
			--AND SP.cdOrigemCalculo = 'S'  --retirado pedido Vinicius 28/07
											
	ELSE
	BEGIN
		UPDATE SP
		SET blAtendePedidoMinimo = 0
		FROM SugestaoPedido SP
		JOIN CD WITH (NOLOCK)
			ON CD.idCD = SP.idCD
		WHERE dtPedido = @DataPedido
			AND IdLoja = @idLoja
			AND IDFornecedorParametro = @idFornecedorParametro
			AND (
				vlTipoReabastecimento IN (7, 37)
				OR (
					CD.blConvertido = 1
					AND SP.vlTipoReabastecimento = 97
					)
				)
			AND qtdPackCompra > 0
			--AND vlForecastMedio > 0	--retirado pedido Vinicius 28/07
			--AND cdOrigemCalculo = 'S'	--retirado pedido Vinicius 28/07
												
		IF @blAdicionaPack = 1
		BEGIN
			SAVE TRANSACTION AntesDoAcrescimo -- essa transaction vai sofrer rollback caso saia do loop sem atender o minimo
			--print 'vai preparar'
			-- Habilita para a iteração todos os itens passivos de adição no pack. (itens em aberto)
			UPDATE SP
			SET SP.blAtendePedidoMinimo = 1
			FROM SugestaoPedido SP WITH (NOLOCK)
			JOIN CD WITH (NOLOCK)
				ON CD.idCD = SP.idCD
			JOIN Loja L WITH (NOLOCK)
				ON L.IDLoja = SP.IdLoja
			JOIN ItemDetalhe ID WITH (NOLOCK)
				ON ID.IDItemDetalhe = SP.IDItemDetalhePedido
			CROSS APPLY dbo.fnBuscaGrade(L.IDBandeira, ID.IDDepartamento, SP.IDLoja) GS
			WHERE SP.dtPedido = @DataPedido
				AND SP.IdLoja = @idLoja
				AND SP.IDFornecedorParametro = @idFornecedorParametro
				AND (
					SP.vlTipoReabastecimento IN (7, 37)
					OR (
						CD.blConvertido = 1
						AND SP.vlTipoReabastecimento = 97
						)
					)
				AND SP.qtdPackCompra > 0
				AND SP.vlForecastMedio > 0
				-- AND SP.cdOrigemCalculo = 'S'	--retirado pedido Vinicius 28/07
				AND SP.blAtendePedidoMinimo = 0
				AND SP.blAtendePedidoMinimoItem = 1
			--print 'o valor acima é o numero de itens que podem entrar na adicao de pack'

			DECLARE @RequerMultiploMinimo BIT, @vlMinimoItem NUMERIC(9,2);

			DECLARE Pedidos CURSOR STATIC FORWARD_ONLY READ_ONLY
			FOR
			SELECT SP.IDSugestaoPedido
				,SP.vlshelflife
				,SP.vlestoque
				,SP.vlforecastmedio
				,SP.vlfatorconversao
				,SP.qtvendorpackage
				,SP.vlmodulo
				,SP.qtdpackcompra
				,CASE ISNULL(ES.vlCustoContabilAtual, 0)
					WHEN 0
						THEN ISNULL(ES.vlCustoCadastroAtual, 0)
					ELSE ISNULL(ES.vlCustoContabilAtual, 0)
					END vlCustoItem
				,CD.blConvertido
				,CASE 
					WHEN ISNULL(SP.vlPesoLiquido, 0) > 1 THEN ROUND(SP.vlPesoLiquido, 0) 
					WHEN ISNULL(SP.vlPesoLiquido, 0) <= 1 THEN 1
					END AS vlPesoLiquido
				,SP.tpCaixaFornecedor
				,SP.vlTipoReabastecimento
				,ISNULL(MI.RequerMultiploMinimo,0)
				,CASE WHEN MI.vlMinimo < 1 THEN 1 ELSE MI.vlMinimo END
			FROM SugestaoPedido SP WITH (NOLOCK)
			LEFT JOIN Estoque ES WITH (NOLOCK)
				ON ES.IDLoja = SP.IdLoja
					AND ES.IDItemDetalhe = SP.IDItemDetalheSugestao
					AND ES.dtRecebimento = (
						SELECT MAX(E.dtRecebimento)
						FROM Estoque E WITH (NOLOCK)
						WHERE E.IDItemDetalhe = ES.IDItemDetalhe
							AND E.IDLoja = ES.IDLoja
						)
			JOIN CD WITH (NOLOCK)
				ON CD.idCD = SP.idCD
			LEFT JOIN #TmpMinimoItem MI
			       ON MI.IDSugestaoPedido = SP.IDSugestaoPedido
			WHERE SP.dtPedido = @DataPedido
				AND SP.IdLoja = @idLoja
				AND SP.IDFornecedorParametro = @idFornecedorParametro
				AND (
					SP.vlTipoReabastecimento IN (7, 37)
					OR (
						CD.blConvertido = 1
						AND SP.vlTipoReabastecimento = 97
						)
					)
				AND SP.qtdPackCompra > 0
				AND SP.vlForecastMedio > 0
				--AND SP.cdOrigemCalculo = 'S'	--retirado pedido Vinicius 28/07
				AND SP.blAtendePedidoMinimo = 1
				AND SP.blAtendePedidoMinimoItem = 1
											
			ORDER BY SP.vlForecastMedio DESC, SP.vlShelfLife DESC

			SET @blAtendePedidoMinimo = 0
			SET @maxShelfLifeAtendido = 0
			--print 'print 3'
											

			WHILE @blAtendePedidoMinimo = 0
				AND @maxShelfLifeAtendido = 0
			BEGIN
				OPEN Pedidos
											
				FETCH NEXT FROM Pedidos
				INTO @idSugestaoPedido
					,@vlShelfLife
					,@vlEstoque
					,@vlForecastMedio
					,@vlFatorConversao
					,@qtVendorPackage
					,@vlModulo
					,@qtPackCompra
					,@vlCustoItem
					,@cdConvertido
					,@vlPesoLiquido
					,@tpCaixaFornecedor
					,@vlTipoReabastecimento
					,@RequerMultiploMinimo
					,@vlMinimoItem

				--print 'print 2'
				--print @idSugestaoPedido
				--print '@@FETCH_STATUS ' + convert(varchar,@@FETCH_STATUS)

				--print 'vai iniciar loop interno'
				IF @@FETCH_STATUS != 0
					SET @maxShelfLifeAtendido = 1
				ELSE
					WHILE @@FETCH_STATUS = 0
						AND @blAtendePedidoMinimo = 0
					BEGIN
						--print 'loop interno'
						--print @vlPedido
						--print @qtDiasEstoque
						--print @vlShelfLife
						--print @vlEstoque
						--print @qtPackCompra 
						--print @vlFatorConversao
						--print @vlForecastMedio
						--print @vlPesoLiquido
						--print @tpPedidoMinimo
						--print @vlFatorConversao
						--print @qtVendorPackage
						--print @vlCustoItem
						--print '-'
						--Se CD não é convertido e não é um item DSD
						IF @cdConvertido = 0 and @vlTipoReabastecimento not in (7,37,97)
													
						BEGIN
							--print 'if 0'
							-- Se é peso variável
							IF @qtVendorPackage = 1 
							BEGIN
								--print 'é 1'
								-- Adiciona uma quantidade do peso bruto ao packcompra da sugestão
								SET @qtPackCompra += @vlModulo
								SET @qtDiasEstoque = CEILING((@vlEstoque + (@qtPackCompra * @vlFatorConversao)) / @vlForecastMedio)
								-- Valida qtde de dias de estoque está dentro do limite de shelflife
								IF @qtDiasEstoque < @vlShelfLife
								BEGIN
									--Atualizar valor total do pedido do vendor
									SET @vlPedido = @vlPedido + (
											(
												@vlModulo * CASE @tpPedidoMinimo
													WHEN '$'
														THEN @vlFatorConversao * @qtVendorPackage * @vlCustoItem
													ELSE 1
													END))
								END
							END
							-- Se é peso fixo @qtVendorPackage <> 1
							ELSE 
							BEGIN
								--print 'é outro que 1'
								-- Adiciona quantidade 1 ao packcompra da sugestão
								SET @qtPackCompra += 1
								SET @qtDiasEstoque = CEILING(@vlEstoque + (@qtPackCompra * @qtVendorPackage * @vlFatorConversao)) / @vlForecastMedio
								-- Valida qtde de dias de estoque está dentro do limite de shelflife
								IF @qtDiasEstoque < @vlShelfLife
								BEGIN
									--Atualizar valor total do pedido do vendor
									SET @vlPedido = @vlPedido + (
											CASE @tpPedidoMinimo
												WHEN '$'
													THEN @vlFatorConversao * @qtVendorPackage * @vlCustoItem 
												ELSE 1
												END )
								END 
							END
						END
						--Se CD convertido ou é um item DSD
						ELSE 
						BEGIN
							--print 'if 1'
							-- Se é peso variável
							IF @tpCaixaFornecedor = 'V'
							BEGIN
								--print 'é V'
								--print 'vai somar '
								--print @vlPesoLiquido
								-- Adiciona uma quantidade do peso líquido ao packcompra da sugestão
								SET @qtPackCompra += @vlPesoLiquido
								SET @qtDiasEstoque = CEILING((@vlEstoque + (@qtPackCompra * @vlFatorConversao)) / @vlForecastMedio)
								-- Valida qtde de dias de estoque está dentro do limite de shelflife
								-- Se chegar ao máximo do shelflife não adiciona mais quantidade para a sugestão
								IF @qtDiasEstoque < @vlShelfLife
									--Atualizar valor total do pedido do vendor
									SET @vlPedido = @vlPedido + (
											@vlPesoLiquido * CASE @tpPedidoMinimo
												WHEN '$'
													THEN @vlFatorConversao * @qtVendorPackage * @vlCustoItem
												ELSE 1
												END
											)
							END
							-- Se é peso fixo @tpCaixaFornecedor <> 'V' (='F')
							ELSE
							BEGIN
								--print 'é outro'
								-- Adiciona quantidade 1 ao packcompra da sugestão
								SET @qtPackCompra += CASE WHEN @tpCaixaFornecedor = 'F' THEN @vlMinimoItem ELSE 1 END
								SET @qtDiasEstoque = CEILING(@vlEstoque + (@qtPackCompra * @qtVendorPackage * @vlFatorConversao)) / @vlForecastMedio
								-- Valida qtde de dias de estoque está dentro do limite de shelflife
								IF @qtDiasEstoque < @vlShelfLife
								BEGIN
									SET @vlPedido = @vlPedido + ( CASE @tpPedidoMinimo
											WHEN '$'
												THEN @vlFatorConversao * @qtVendorPackage * @vlCustoItem
											ELSE 
												CASE WHEN @tpCaixaFornecedor = 'F' THEN @vlMinimoItem ELSE 1 END
											END )
								END
							END
						END

						--print 'vlPedido fica'
						--print @vlPedido
						--print @qtDiasEstoque
						--print @vlShelfLife
						--print @vlEstoque
						--print 'qtdPackCompra=' + convert(varchar, @qtPackCompra )
						--print @vlFatorConversao
						--print @vlForecastMedio
						--print @vlPesoLiquido
						--print @tpPedidoMinimo
						--print @vlFatorConversao
						--print @qtVendorPackage
						--print @vlCustoItem
						--print 'vlMinimo'
						--print @vlMinimoItem
						--print @RequerMultiploMinimo
						--print '-'
						--Valida se com a adição do pack o total do pedido do vendor atinge o mínimo
						IF @vlPedido >= @vlPedidoMinimo
							SET @blAtendePedidoMinimo = 1

						--Se o shelflife não foi atingido ainda atualiza a sugestão de compra com a quantidade adicionada
						IF @qtDiasEstoque < @vlShelfLife
							BEGIN
							UPDATE SugestaoPedido
							SET vlQtdDiasEstoque = @qtDiasEstoque
								,qtdPackCompra = @qtPackCompra
							WHERE IDSugestaoPedido = @idSugestaoPedido
							END

						ELSE
							BEGIN
							UPDATE SugestaoPedido
							SET blAtendePedidoMinimo = 0
							WHERE IDSugestaoPedido = @idSugestaoPedido
							END

						FETCH NEXT FROM Pedidos
						INTO @idSugestaoPedido
							,@vlShelfLife
							,@vlEstoque
							,@vlForecastMedio
							,@vlFatorConversao
							,@qtVendorPackage
							,@vlModulo
							,@qtPackCompra
							,@vlCustoItem
							,@cdConvertido
							,@vlPesoLiquido
							,@tpCaixaFornecedor
							,@vlTipoReabastecimento
							,@RequerMultiploMinimo
							,@vlMinimoItem

					END

				CLOSE Pedidos
			END

			DEALLOCATE Pedidos

			IF (@blAtendePedidoMinimo = 0)
			BEGIN
				ROLLBACK TRANSACTION AntesDoAcrescimo -- mesmo incrementando, nao atingiu o minimo; descarta todas as alteracoes, voltando para o estado em que estava no inicio do loop
			END 
										
										
			UPDATE SP
			SET blAtendePedidoMinimo = @blAtendePedidoMinimo
			FROM SugestaoPedido SP
			JOIN CD WITH (NOLOCK)
				ON CD.idCD = SP.idCD
			WHERE dtPedido = @DataPedido
				AND IdLoja = @idLoja
				AND IDFornecedorParametro = @idFornecedorParametro
				AND (
					vlTipoReabastecimento IN (7, 37)
					OR (
						CD.blConvertido = 1
						AND SP.vlTipoReabastecimento = 97
						)
					)
				AND qtdPackCompra > 0
				AND vlForecastMedio > 0
				--AND cdOrigemCalculo = 'S'	--retirado pedido Vinicius 28/07
												
		END
	END

	IF OBJECT_ID('Tempdb..#TmpMinimoItem') IS NOT NULL
	BEGIN
		DROP TABLE #TmpMinimoItem
	END

	IF (@AbriuTrn = 1)
	BEGIN
		COMMIT TRAN
	END

END
				]]>
			</sql>
		</rollback>
	</changeSet>
</databaseChangeLog>

